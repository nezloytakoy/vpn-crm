import { Bot, webhookCallback, Context, InlineKeyboard } from 'grammy';
import { PrismaClient } from '@prisma/client';
import { Prisma } from '@prisma/client';
import axios from 'axios';
import { InputFile } from 'grammy';


const token = process.env.TELEGRAM_SUPPORT_BOT_TOKEN;
if (!token) throw new Error('TELEGRAM_SUPPORT_BOT_TOKEN not found.');

const bot = new Bot(token);
const prisma = new PrismaClient();

const assistantBot = new Bot(process.env.TELEGRAM_SUPPORT_BOT_TOKEN || "");

const userBot = new Bot(process.env.TELEGRAM_USER_BOT_TOKEN!);


type TelegramButton = {
  text: string;
  callback_data: string;
};


async function sendTelegramMessageWithButtons(chatId: string, text: string, buttons: TelegramButton[]) {
  const botToken = process.env.TELEGRAM_SUPPORT_BOT_TOKEN;
  const url = `https://api.telegram.org/bot${botToken}/sendMessage`;

  await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      chat_id: chatId,
      text,
      reply_markup: {
        inline_keyboard: buttons.map((button) => [{ text: button.text, callback_data: button.callback_data }]),
      },
    }),
  });
}


async function sendTelegramMessageToUser(chatId: string, text: string) {
  const botToken = process.env.TELEGRAM_USER_BOT_TOKEN;
  if (!botToken) {
    console.error('–û—à–∏–±–∫–∞: TELEGRAM_USER_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω');
    return;
  }

  const url = `https://api.telegram.org/bot${botToken}/sendMessage`;

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ chat_id: chatId, text }),
    });

    if (!response.ok) {
      throw new Error(`–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: ${response.statusText}`);
    }

    console.log(`–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Å ID: ${chatId}`);

    const userTelegramId = BigInt(chatId);


    const activeConversation = await prisma.conversation.findFirst({
      where: {
        userId: userTelegramId,
        status: 'IN_PROGRESS',
      },
    });

    if (activeConversation) {
      const currentTime = new Date();


      if (activeConversation.lastMessageFrom === 'USER' && activeConversation.lastUserMessageAt) {
        const lastUserMessageTime = new Date(activeConversation.lastUserMessageAt).getTime();
        const responseTime = currentTime.getTime() - lastUserMessageTime;

        const responseTimesArray: Prisma.JsonArray = Array.isArray(activeConversation.assistantResponseTimes)
          ? activeConversation.assistantResponseTimes as Prisma.JsonArray
          : [];


        responseTimesArray.push(responseTime);


        const newAssistantMessage = {
          sender: 'ASSISTANT',
          message: text,
          timestamp: currentTime.toISOString(),
        };


        const updatedMessages = [
          ...(activeConversation.messages as Array<{ sender: string; message: string; timestamp: string }>),
          newAssistantMessage,
        ];


        await prisma.conversation.update({
          where: { id: activeConversation.id },
          data: {
            lastMessageFrom: 'ASSISTANT',
            assistantResponseTimes: responseTimesArray,
            messages: updatedMessages,
          },
        });
      } else {

        const newAssistantMessage = {
          sender: 'ASSISTANT',
          message: text,
          timestamp: currentTime.toISOString(),
        };


        const updatedMessages = [
          ...(activeConversation.messages as Array<{ sender: string; message: string; timestamp: string }>),
          newAssistantMessage,
        ];


        await prisma.conversation.update({
          where: { id: activeConversation.id },
          data: {
            lastMessageFrom: 'ASSISTANT',
            messages: updatedMessages,
          },
        });
      }
    } else {
      console.error('–û—à–∏–±–∫–∞: –∞–∫—Ç–∏–≤–Ω—ã–π —Ä–∞–∑–≥–æ–≤–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è');
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é:', error);
  }
}




type TranslationKey = keyof typeof translations["en"];

const getTranslation = (lang: "en" | "ru", key: TranslationKey) => {
  return translations[lang][key] || translations["en"][key];
};

const translations = {
  en: {
    end_dialog_error: "Error: could not get your Telegram ID.",
    no_active_requests: "‚ö†Ô∏è You have no active requests.",
    dialog_closed: "The dialog with the user has been closed.",
    assistant_finished_dialog: "The assistant has finished the dialog.",
    start_invalid_link: "‚ùå The link is invalid or has already been used.",
    assistant_congrats: "üéâ Congratulations, you are now an assistant!",
    start_message: "üëã This is the support bot! Use a valid invite link to access the functionality.",
    menu_message: "üìã Main menu:",
    start_work: "üöÄ Start working!",
    my_coins: "üí∞ My coins",
    my_activity: "üìä My activity",
    already_working: "‚ö†Ô∏è You are already working!",
    work_started: "üöÄ Work started! To end, use the /end_work command.",
    end_work: "üö™ Work finished!",
    no_working_status: "‚ö†Ô∏è You are not working at the moment!",
    accept_request: "‚úÖ You have accepted the request. Please wait for the user's question.",
    reject_request: "‚ùå You have rejected the request.",
    send_message_error: "Please send a text message.",
    no_user_requests: "‚ö†Ô∏è You have no active user requests.",
    error_processing_message: "An error occurred while processing your message. Please try again later.",
    active_dialog_exists: "‚ö†Ô∏è You have an active dialog. Please finish it before ending work.",
    assistantRequestMessage: "User request for conversation",
    accept: "Accept",
    reject: "Reject",
    requestSent: "The request has been sent to the assistant.",
    active_requests_list: "üìÑ Here is the list of active user requests:",
    server_error: "‚ö†Ô∏è An error occurred on the server. Please try again later.",
    no_message: "No message provided.",
    no_assistant_found: "‚ùå Assistant not found.",
    request_not_found_or_not_assigned: "‚ùå Request not found or not assigned to you.",
    activated_request_with_subject: "Activated request with subject",
    now_chatting_with_user: "Now chatting with user",
    request_withdrawal: "Request withdrawal",
    total_conversations: "Total conversations",
    conversations_last_24_hours: "Conversations in the last 24 hours",
    ignored_requests: "Ignored requests",
    rejected_requests: "Rejected requests",
    complaints_last_24_hours: "Complaints in the last 24 hours",
    view_limits: "View limits",
    complaint_pending: "Complaint is pending. You cannot withdraw until it is resolved.",
    balance_frozen: "Your balance is frozen for 24 hours due to low activity.",
    withdrawal_request_sent: "Withdrawal request sent.",
    withdrawal_request_created: "Your withdrawal request has been created successfully.",
    limits_info: "If skipped requests exceed 3 or rejections exceed 10 in a day, your activity will decrease, and your balance will be frozen for 24 hours. Complaints also pause withdrawals until resolved.",
    unknown_action: "Unknown action.",
  },
  ru: {
    end_dialog_error: "–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –≤–∞—à –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä Telegram.",
    no_active_requests: "‚ö†Ô∏è –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç.",
    dialog_closed: "–î–∏–∞–ª–æ–≥ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω.",
    assistant_finished_dialog: "–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç –∑–∞–≤–µ—Ä—à–∏–ª –¥–∏–∞–ª–æ–≥.",
    start_invalid_link: "‚ùå –°—Å—ã–ª–∫–∞ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –∏–ª–∏ —É–∂–µ –±—ã–ª–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞.",
    assistant_congrats: "üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º, –≤—ã —Å—Ç–∞–ª–∏ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–º!",
    start_message: "üëã –≠—Ç–æ –±–æ—Ç –¥–ª—è —Å–∞–ø–ø–æ—Ä—Ç–æ–≤! –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—É—é –ø—Ä–∏–≥–ª–∞—Å–∏—Ç–µ–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—É.",
    menu_message: "üìã –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:",
    start_work: "üöÄ –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É!",
    my_coins: "üí∞ –ú–æ–∏ –∫–æ–∏–Ω—ã",
    my_activity: "üìä –ú–æ—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å",
    already_working: "‚ö†Ô∏è –í—ã —É–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç–µ!",
    work_started: "üöÄ –†–∞–±–æ—Ç–∞ –Ω–∞—á–∞—Ç–∞! –ß—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–∏—Ç—å —Ä–∞–±–æ—Ç—É, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /end_work.",
    end_work: "üö™ –†–∞–±–æ—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!",
    no_working_status: "‚ö†Ô∏è –í—ã –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç–µ –≤ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç!",
    accept_request: "‚úÖ –í—ã –ø—Ä–∏–Ω—è–ª–∏ –∑–∞–ø—Ä–æ—Å. –û–∂–∏–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.",
    reject_request: "‚ùå –í—ã –æ—Ç–∫–ª–æ–Ω–∏–ª–∏ –∑–∞–ø—Ä–æ—Å.",
    send_message_error: "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.",
    no_user_requests: "‚ö†Ô∏è –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.",
    error_processing_message: "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –ø–æ–∑–∂–µ.",
    active_dialog_exists: "‚ö†Ô∏è –£ –≤–∞—Å –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–π –¥–∏–∞–ª–æ–≥. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≤–µ—Ä—à–∏—Ç–µ –µ–≥–æ –ø–µ—Ä–µ–¥ —Ç–µ–º, –∫–∞–∫ –∑–∞–∫–æ–Ω—á–∏—Ç—å —Ä–∞–±–æ—Ç—É.",
    assistantRequestMessage: "–ó–∞–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ —Ä–∞–∑–≥–æ–≤–æ—Ä",
    accept: "–ü—Ä–∏–Ω—è—Ç—å",
    reject: "–û—Ç–∫–ª–æ–Ω–∏—Ç—å",
    requestSent: "–ó–∞–ø—Ä–æ—Å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç—É.",
    active_requests_list: "üìÑ –í–æ—Ç —Å–ø–∏—Å–æ–∫ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:",
    server_error: "‚ö†Ô∏è –ù–∞ —Å–µ—Ä–≤–µ—Ä–µ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
    no_message: "–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.",
    no_assistant_found: "‚ùå –ê—Å—Å–∏—Å—Ç–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.",
    request_not_found_or_not_assigned: "‚ùå –ó–∞–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω –≤–∞–º.",
    activated_request_with_subject: "–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –∑–∞–ø—Ä–æ—Å —Å —Ç–µ–º–æ–π",
    now_chatting_with_user: "–°–µ–π—á–∞—Å –æ–±—â–∞–µ—Ç–µ—Å—å —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º",
    request_withdrawal: "–ó–∞–ø—Ä–æ—Å–∏—Ç—å –≤—ã–≤–æ–¥",
    total_conversations: "–í—Å–µ–≥–æ –¥–∏–∞–ª–æ–≥–æ–≤",
    conversations_last_24_hours: "–î–∏–∞–ª–æ–≥–æ–≤ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞",
    ignored_requests: "–ü—Ä–æ–ø—É—â–µ–Ω–æ –∑–∞–ø—Ä–æ—Å–æ–≤",
    rejected_requests: "–û—Ç–∫–ª–æ–Ω–µ–Ω–æ –∑–∞–ø—Ä–æ—Å–æ–≤",
    complaints_last_24_hours: "–ñ–∞–ª–æ–±—ã –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞",
    view_limits: "–ü—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ª–∏–º–∏—Ç—ã",
    complaint_pending: "–ù–∞ –≤–∞—Å –Ω–∞–ø–∏—Å–∞–Ω–∞ –∂–∞–ª–æ–±–∞. –í—ã–≤–æ–¥ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –ø–æ–∫–∞ –æ–Ω–∞ –Ω–µ –±—É–¥–µ—Ç —Ä–µ—à–µ–Ω–∞.",
    balance_frozen: "–í–∞—à –±–∞–ª–∞–Ω—Å –∑–∞–º–æ—Ä–æ–∂–µ–Ω –Ω–∞ 24 —á–∞—Å–∞ –∏–∑-–∑–∞ –Ω–∏–∑–∫–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏.",
    withdrawal_request_sent: "–ó–∞–ø—Ä–æ—Å –Ω–∞ –≤—ã–≤–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.",
    withdrawal_request_created: "–í–∞—à –∑–∞–ø—Ä–æ—Å –Ω–∞ –≤—ã–≤–æ–¥ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω.",
    limits_info: "–ï—Å–ª–∏ –∑–∞ —Å—É—Ç–∫–∏ –≤—ã –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ –±–æ–ª–µ–µ 3 –∑–∞–ø—Ä–æ—Å–æ–≤ –∏–ª–∏ –æ—Ç–∫–ª–æ–Ω–∏—Ç–µ –±–æ–ª–µ–µ 10, –≤–∞—à–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å–Ω–∏–∑–∏—Ç—Å—è, –∏ –±–∞–ª–∞–Ω—Å –∑–∞–º–æ—Ä–æ–∑–∏—Ç—Å—è –Ω–∞ 24 —á–∞—Å–∞. –ñ–∞–ª–æ–±—ã —Ç–∞–∫–∂–µ –≤—Ä–µ–º–µ–Ω–Ω–æ –±–ª–æ–∫–∏—Ä—É—é—Ç –≤—ã–≤–æ–¥ –¥–æ –∏—Ö —Ä–µ—à–µ–Ω–∏—è.",
    unknown_action: "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ.",
  },
};



const detectUserLanguage = (ctx: Context) => {
  const userLang = ctx.from?.language_code;
  return userLang === 'ru' ? 'ru' : 'en';
};


async function getAssistantPenaltyPoints(assistantId: bigint) {
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);

  const actions = await prisma.requestAction.findMany({
    where: {
      assistantId: assistantId,
      createdAt: {
        gte: yesterday,
      },
    },
  });

  let penaltyPoints = 0;
  for (const action of actions) {
    if (action.action === 'REJECTED') {
      penaltyPoints += 1;
    } else if (action.action === 'IGNORED') {
      penaltyPoints += 3;
    }
  }

  return penaltyPoints;
}


async function findNewAssistant(requestId: bigint, ignoredAssistants: bigint[]) {

  const availableAssistants = await prisma.assistant.findMany({
    where: {
      isWorking: true,
      telegramId: {
        notIn: ignoredAssistants,
      },
    },
  });


  const assistantsWithPenalty = await Promise.all(
    availableAssistants.map(async (assistant) => {
      const penaltyPoints = await getAssistantPenaltyPoints(assistant.telegramId);
      return { ...assistant, penaltyPoints };
    })
  );


  assistantsWithPenalty.sort((a, b) => {
    if (a.penaltyPoints === b.penaltyPoints) {

      return (b.lastActiveAt?.getTime() || 0) - (a.lastActiveAt?.getTime() || 0);
    }
    return a.penaltyPoints - b.penaltyPoints;
  });


  const selectedAssistant = assistantsWithPenalty[0];


  if (!selectedAssistant) {
    await prisma.assistantRequest.update({
      where: { id: requestId },
      data: { ignoredAssistants: [] },
    });
    return findNewAssistant(requestId, []);
  }

  return selectedAssistant;
}


async function checkAssistantBlockStatus(ctx: Context) {
  if (!ctx.from?.id) {
    console.log("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π ID –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ.");
    return;
  }

  const telegramId = BigInt(ctx.from.id);
  console.log(`–ü—Ä–æ–≤–µ—Ä–∫–∞ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å ID: ${telegramId.toString()}`);

  const assistant = await prisma.assistant.findUnique({
    where: { telegramId },
    select: { isBlocked: true, unblockDate: true },
  });

  if (!assistant) {
    console.log(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID: ${telegramId.toString()} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ.`);
    return false;
  }

  console.log(
    `–î–∞–Ω–Ω—ã–µ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞: isBlocked=${assistant.isBlocked}, unblockDate=${assistant.unblockDate}`
  );

  if (assistant.isBlocked && assistant.unblockDate) {
    const currentTime = new Date();
    console.log(`–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è: ${currentTime.toISOString()}`);
    console.log(`–î–∞—Ç–∞ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏: ${assistant.unblockDate.toISOString()}`);

    const remainingTime = Math.ceil(
      (assistant.unblockDate.getTime() - currentTime.getTime()) / (1000 * 60 * 60)
    );

    console.log(`–û—Å—Ç–∞–≤—à–µ–µ—Å—è –≤—Ä–µ–º—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏: ${remainingTime}—á`);

    if (remainingTime > 0) {
      console.log(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${telegramId.toString()} –µ—â—ë –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω. –û—Å—Ç–∞–≤—à–µ–µ—Å—è –≤—Ä–µ–º—è: ${remainingTime}—á`);

      await ctx.reply(
        `–í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º, –¥–æ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –æ—Å—Ç–∞–ª–æ—Å—å ${remainingTime}—á.`
      );
      return true;
    } else {
      console.log(
        `–í—Ä–µ–º—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${telegramId.toString()} –∏—Å—Ç–µ–∫–ª–æ. –°–Ω–∏–º–∞–µ–º –±–ª–æ–∫–∏—Ä–æ–≤–∫—É.`
      );

      await prisma.assistant.update({
        where: { telegramId },
        data: { isBlocked: false, unblockDate: null },
      });

      console.log(
        `–ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${telegramId.toString()} —É—Å–ø–µ—à–Ω–æ —Å–Ω—è—Ç–∞ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö.`
      );

      await ctx.reply(
        "–í—Ä–µ–º—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –≤—ã—à–ª–æ, –≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º."
      );
    }
  } else {
    console.log(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${telegramId.toString()} –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω.`);
  }

  return false;
}

bot.use(async (ctx, next) => {
  console.log("–ó–∞–ø—É—Å–∫ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–≥–æ —Å–ª–æ—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏.");
  const isBlocked = await checkAssistantBlockStatus(ctx);

  if (isBlocked) {
    console.log("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω. –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É.");
    return;
  }

  console.log("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω. –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ.");
  await next();
});


bot.command('requests', async (ctx) => {
  const lang = detectUserLanguage(ctx);

  try {
    if (!ctx.from?.id) {
      await ctx.reply(getTranslation(lang, 'end_dialog_error'));
      return;
    }

    const telegramId = BigInt(ctx.from.id);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–º
    const assistant = await prisma.assistant.findUnique({
      where: { telegramId },
    });

    if (!assistant) {
      await ctx.reply(getTranslation(lang, 'no_assistant_found'));
      return;
    }

    // –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –±–µ—Å–µ–¥—ã –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
    const activeConversations = await prisma.conversation.findMany({
      where: {
        assistantId: telegramId,
        status: 'IN_PROGRESS',
      },
      include: {
        assistantRequest: true,
      },
    });

    if (activeConversations.length === 0) {
      await ctx.reply(getTranslation(lang, 'no_active_requests'));
      return;
    }

    // –§–æ—Ä–º–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
    const inlineKeyboard = activeConversations.map((conversation) => {
      const subject = conversation.assistantRequest.subject || getTranslation(lang, 'no_message');
      const timeRemaining = calculateTimeRemaining(conversation.createdAt);
      return [
        {
          text: `–ó–∞–ø—Ä–æ—Å: ${subject} | –û—Å—Ç–∞–ª–æ—Å—å: ${timeRemaining}`,
          callback_data: `activate_${conversation.id}`,
        },
      ];
    });

    await ctx.reply(getTranslation(lang, 'active_requests_list'), {
      reply_markup: { inline_keyboard: inlineKeyboard },
    });
  } catch (error) {
    console.error('Error fetching requests:', error);
    await ctx.reply(getTranslation(lang, 'server_error'));
  }
});

function calculateTimeRemaining(createdAt: Date): string {
  const maxDuration = 60 * 60 * 1000; // 60 –º–∏–Ω—É—Ç
  const timePassed = Date.now() - createdAt.getTime();
  const timeLeft = maxDuration - timePassed;

  if (timeLeft <= 0) {
    return '–≤—Ä–µ–º—è –∏—Å—Ç–µ–∫–ª–æ';
  }

  const minutes = Math.floor(timeLeft / (60 * 1000));
  const seconds = Math.floor((timeLeft % (60 * 1000)) / 1000);

  return `${minutes}–º ${seconds}—Å`;
}

async function reassignRequest(requestId: bigint, blockedAssistantId: bigint, ctx: Context) {
  try {
    const assistantRequest = await prisma.assistantRequest.findUnique({
      where: { id: requestId },
      include: { conversation: true },
    });

    const ignoredAssistants = assistantRequest?.ignoredAssistants || [];
    if (!ignoredAssistants.includes(blockedAssistantId)) {
      ignoredAssistants.push(blockedAssistantId);
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ –Ω–∞ ABORTED, —Ç–∞–∫ –∫–∞–∫ —Å–≤—è–∑—å –ø–æ—Ç–µ—Ä—è–Ω–∞
    if (assistantRequest?.conversation) {
      await prisma.conversation.update({
        where: { id: assistantRequest.conversation.id },
        data: { status: 'ABORTED' },
      });
    }

    // –ü–µ—Ä–µ–≤–æ–¥–∏–º –∑–∞–ø—Ä–æ—Å –≤ —Ä–µ–∂–∏–º –æ–∂–∏–¥–∞–Ω–∏—è –¥—Ä—É–≥–æ–≥–æ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
    await prisma.assistantRequest.update({
      where: { id: requestId },
      data: {
        status: 'PENDING',
        isActive: true,
        assistantId: null,
        ignoredAssistants,
      },
    });

    // –ù–∞—Ö–æ–¥–∏–º –Ω–æ–≤–æ–≥–æ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
    const newAssistant = await findNewAssistant(requestId, ignoredAssistants);

    // –ü–æ–ª—É—á–∞–µ–º userId –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–º—É –Ω—É–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ
    const userId = assistantRequest?.conversation?.userId;

    if (!userId) {
      console.error('User ID not found in the conversation. Cannot send a message to user.');
      return;
    }

    if (newAssistant) {
      // –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å —Å –Ω–æ–≤—ã–º –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–º
      await prisma.assistantRequest.update({
        where: { id: requestId },
        data: {
          assistantId: newAssistant.telegramId,
        },
      });

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–º—É –∑–∞–ø—Ä–æ—Å–∞ –∏–ª–∏ –º–µ–¥–∏–∞ –Ω–æ–≤–æ–º—É –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç—É (–µ—Å–ª–∏ –µ—Å—Ç—å)
      if (assistantRequest?.subject) {
        const caption = '–¢–µ–º–∞ –∑–∞–ø—Ä–æ—Å–∞ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è';
        if (assistantRequest.subject.startsWith('http')) {
          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –º–µ–¥–∏–∞
          await sendTelegramMediaToAssistant(
            newAssistant.telegramId.toString(),
            assistantRequest.subject,
            caption
          );
        } else {
          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –±–µ–∑ –∫–Ω–æ–ø–æ–∫
          await sendTelegramMessageWithButtons(
            newAssistant.telegramId.toString(),
            `–¢–µ–º–∞ –∑–∞–ø—Ä–æ—Å–∞: ${assistantRequest.subject}`,
            []
          );
        }
      }

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏ (accept/reject)
      await sendTelegramMessageWithButtons(
        newAssistant.telegramId.toString(),
        assistantRequest?.message || '–ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è',
        [
          { text: getTranslation('en', 'accept'), callback_data: `accept_${requestId}` },
          { text: getTranslation('en', 'reject'), callback_data: `reject_${requestId}` },
        ]
      );

      // –°–æ–æ–±—â–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —á–µ—Ä–µ–∑ userBot
      await userBot.api.sendMessage(Number(userId), '–°–≤—è–∑—å —Å –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–º –ø–æ—Ç–µ—Ä—è–Ω–∞, –ø–æ–¥–∫–ª—é—á–∞–µ–º –¥—Ä—É–≥–æ–≥–æ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞...');
    } else {
      // –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–≤
      await userBot.api.sendMessage(Number(userId), '–°–≤—è–∑—å —Å –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–º –ø–æ—Ç–µ—Ä—è–Ω–∞, –Ω–æ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–≤ –±–æ–ª—å—à–µ –Ω–µ—Ç.');
    }

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–µ–Ω–∏–∏ –∑–∞–ø—Ä–æ—Å–∞:', error);
    // –ï—Å–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞, —É–≤–µ–¥–æ–º–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ–± –æ—à–∏–±–∫–µ
    // –ú–æ–∂–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –ø—Ä–æ–±–ª–µ–º–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –∏–ª–∏ –∂–µ –ª–æ–≥–∏—Ä–æ–≤–∞—Ç—å –±–µ–∑ –æ—Ç–≤–µ—Ç–∞
    const assistantRequest = await prisma.assistantRequest.findUnique({
      where: { id: requestId },
      include: { conversation: true },
    });
    const userId = assistantRequest?.conversation?.userId;
    if (userId) {
      await userBot.api.sendMessage(Number(userId), '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–µ–Ω–∏–∏ –∑–∞–ø—Ä–æ—Å–∞.');
    }
  }
}


bot.command('end_work', async (ctx) => {
  try {
    if (!ctx.from?.id) {
      await ctx.reply(getTranslation(detectUserLanguage(ctx), 'end_dialog_error'));
      return;
    }

    const telegramId = BigInt(ctx.from.id);
    const lang = detectUserLanguage(ctx);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –¥–∏–∞–ª–æ–≥–∞
    const activeConversation = await prisma.conversation.findFirst({
      where: {
        assistantId: telegramId,
        status: 'IN_PROGRESS',
      },
    });

    // –ï—Å–ª–∏ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ –¥–∏–∞–ª–æ–≥–∏ - –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏
    if (activeConversation) {
      const keyboard = new InlineKeyboard()
        .text('–ó–∞–≤–µ—Ä—à–∏—Ç—å —Ä–∞–±–æ—Ç—É', 'end_work_confirm')
        .row()
        .text('–í–µ—Ä–Ω—É—Ç—å—Å—è –∫ —Ä–∞–±–æ—Ç–µ', 'end_work_cancel');

      await ctx.reply(
        '–£ –≤–∞—Å –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ –¥–∏–∞–ª–æ–≥–∏. –ï—Å–ª–∏ –≤—ã –∑–∞–≤–µ—Ä—à–∏—Ç–µ —Ä–∞–±–æ—Ç—É, –≤—ã –Ω–µ –ø–æ–ª—É—á–∏—Ç–µ –∫–æ–∏–Ω–æ–≤ –∏ –±—É–¥–µ—Ç–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –¥–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏—è —Å–∏—Ç—É–∞—Ü–∏–µ–π –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–µ–π. –ó–∞–≤–µ—Ä—à–∏—Ç—å —Ä–∞–±–æ—Ç—É?',
        { reply_markup: keyboard }
      );
      return;
    }

    // –ü–æ–ª—É—á–∞–µ–º –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
    const assistant = await prisma.assistant.findUnique({
      where: { telegramId: telegramId },
    });

    if (!assistant) {
      console.error(`Assistant not found with telegramId: ${telegramId}`);
      await ctx.reply(getTranslation(lang, 'no_assistant_found'));
      return;
    }

    if (!assistant.isWorking) {
      await ctx.reply(getTranslation(lang, 'no_working_status'));
      return;
    }

    // –ó–∞–≤–µ—Ä—à–∞–µ–º –∞–∫—Ç–∏–≤–Ω—É—é —Å–µ—Å—Å–∏—é, –µ—Å–ª–∏ –µ—Å—Ç—å
    const activeSession = await prisma.assistantSession.findFirst({
      where: {
        assistantId: telegramId,
        endedAt: null,
      },
      orderBy: {
        startedAt: 'desc',
      },
    });

    if (activeSession) {
      await prisma.assistantSession.update({
        where: { id: activeSession.id },
        data: { endedAt: new Date() },
      });
    } else {
      console.warn(`No active session found for assistant ${telegramId}`);
    }

    // –†–∞–Ω–µ–µ –º—ã —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–ª–∏ isWorking=false –∑–¥–µ—Å—å, —Ç–µ–ø–µ—Ä—å —ç—Ç–æ –¥–µ–ª–∞–µ—Ç—Å—è –≤ –∫–æ–ª–±—ç–∫–µ
    await ctx.reply(getTranslation(lang, 'end_work'));
  } catch (error) {
    console.error('Error ending work:', error);
    await ctx.reply(getTranslation(detectUserLanguage(ctx), 'end_dialog_error'));
  }
});

bot.callbackQuery('end_work_confirm', async (ctx) => {
  try {
    const telegramId = BigInt(ctx.from.id);
    const lang = detectUserLanguage(ctx);

    // –ü–æ–ª—É—á–∞–µ–º –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
    const assistant = await prisma.assistant.findUnique({
      where: { telegramId: telegramId },
    });

    if (!assistant) {
      console.error(`Assistant not found with telegramId: ${telegramId}`);
      await ctx.answerCallbackQuery();
      await ctx.reply(getTranslation(lang, 'no_assistant_found'));
      return;
    }

    // –ó–∞–≤–µ—Ä—à–∞–µ–º –∞–∫—Ç–∏–≤–Ω—É—é —Å–µ—Å—Å–∏—é, –µ—Å–ª–∏ –µ—Å—Ç—å
    const activeSession = await prisma.assistantSession.findFirst({
      where: {
        assistantId: telegramId,
        endedAt: null,
      },
      orderBy: {
        startedAt: 'desc',
      },
    });

    if (activeSession) {
      await prisma.assistantSession.update({
        where: { id: activeSession.id },
        data: { endedAt: new Date() },
      });
    }

    // –ó–∞–≤–µ—Ä—à–∞–µ–º –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –¥–∏–∞–ª–æ–≥–∏ (–º–µ–Ω—è–µ–º —Å—Ç–∞—Ç—É—Å –Ω–∞ COMPLETED)
    await prisma.conversation.updateMany({
      where: {
        assistantId: telegramId,
        status: 'IN_PROGRESS',
      },
      data: {
        status: 'COMPLETED',
      },
    });

    // –ë–ª–æ–∫–∏—Ä—É–µ–º –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
    await prisma.assistant.update({
      where: { telegramId: telegramId },
      data: {
        isWorking: false,
        isBlocked: true,
        unblockDate: null
      },
    });

    await ctx.answerCallbackQuery();
    await ctx.editMessageText('–†–∞–±–æ—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –í—ã –Ω–µ –ø–æ–ª—É—á–∏—Ç–µ –≤–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏–µ –∏ –≤–∞—à –∞–∫–∫–∞—É–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –¥–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–µ–π.');

    // –ù–∞–π–¥—ë–º –ª—é–±–æ–π –∑–∞–≤–µ—Ä—à—ë–Ω–Ω—ã–π —Å–µ–π—á–∞—Å —Ä–∞–∑–≥–æ–≤–æ—Ä, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å requestId
    const completedConversation = await prisma.conversation.findFirst({
      where: {
        assistantId: telegramId,
        status: 'COMPLETED',
      },
      orderBy: { updatedAt: 'desc' }
    });

    if (completedConversation) {
      const userId = completedConversation.userId;

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —á–µ—Ä–µ–∑ userBot
      await userBot.api.sendMessage(Number(userId), '–°–≤—è–∑—å —Å –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–º –ø–æ—Ç–µ—Ä—è–Ω–∞, –ø–æ–¥–∫–ª—é—á–∞–µ–º –¥—Ä—É–≥–æ–≥–æ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞...');

      // –ü–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–∞–µ–º –∑–∞–ø—Ä–æ—Å –¥—Ä—É–≥–æ–º—É –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç—É
      await reassignRequest(completedConversation.requestId, telegramId, ctx);
    }

  } catch (error) {
    console.error('Error confirming end work:', error);
    await ctx.answerCallbackQuery();
    await ctx.reply(getTranslation(detectUserLanguage(ctx), 'end_dialog_error'));
  }
});

bot.callbackQuery('end_work_cancel', async (ctx) => {
  try {
    await ctx.answerCallbackQuery();
    // –ü—Ä–æ—Å—Ç–æ —É–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏
    await ctx.deleteMessage();
  } catch (error) {
    console.error('Error canceling end work:', error);
  }
});



bot.command('menu', async (ctx) => {
  const lang = detectUserLanguage(ctx);

  try {

    if (!ctx.from?.id) {
      await ctx.reply(getTranslation(lang, 'end_dialog_error'));
      return;
    }

    const telegramId = BigInt(ctx.from.id);


    const assistant = await prisma.assistant.findUnique({
      where: { telegramId: telegramId },
    });

    if (!assistant) {
      await ctx.reply(getTranslation(lang, 'end_dialog_error'));
      return;
    }


    await prisma.assistant.update({
      where: { telegramId: telegramId },
      data: { lastActiveAt: new Date() },
    });


    await ctx.reply(getTranslation(lang, 'menu_message'), {
      reply_markup: {
        inline_keyboard: [
          [{ text: getTranslation(lang, 'start_work'), callback_data: 'start_work' }],
          [{ text: getTranslation(lang, 'my_coins'), callback_data: 'my_coins' }],
          [{ text: getTranslation(lang, 'my_activity'), callback_data: 'my_activity' }],
        ],
      },
    });
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞';
    console.error('Error showing menu:', errorMessage);
  }
});

bot.on('callback_query:data', async (ctx) => {
  const data = ctx.callbackQuery?.data;
  const lang = detectUserLanguage(ctx);

  if (!ctx.from?.id) {
    await ctx.reply(getTranslation(lang, 'end_dialog_error'));
    return;
  }

  const telegramId = BigInt(ctx.from.id);

  if (data?.startsWith('activate_')) {
    // Handle activation of a conversation
    const conversationId = BigInt(data.split('_')[1]);
    const assistantId = telegramId;

    const assistant = await prisma.assistant.findUnique({
      where: { telegramId: assistantId },
    });

    if (!assistant) {
      await ctx.answerCallbackQuery({ text: getTranslation(lang, 'no_assistant_found'), show_alert: true });
      return;
    }

    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId },
      include: { assistantRequest: true, user: true },
    });

    if (!conversation || conversation.assistantId !== assistantId) {
      await ctx.answerCallbackQuery({
        text: getTranslation(lang, 'request_not_found_or_not_assigned'),
        show_alert: true,
      });
      return;
    }

    // Activate the selected conversation for the assistant
    await prisma.assistant.update({
      where: { telegramId: assistantId },
      data: { activeConversationId: conversationId },
    });

    await ctx.answerCallbackQuery({
      text: `${getTranslation(lang, 'activated_request_with_subject')}: ${conversation.assistantRequest.subject}`,
    });
    await ctx.reply(
      `${getTranslation(lang, 'now_chatting_with_user')}: ${conversation.user.username || conversation.userId}`
    );
  } else if (data.startsWith('accept_') || data.startsWith('reject_')) {
    // Handle accept or reject actions
    const [action, requestIdString] = data.split('_');
    const requestId = BigInt(requestIdString);

    if (action === 'accept') {
      await handleAcceptRequest(requestId.toString(), telegramId, ctx);
    } else if (action === 'reject') {
      await handleRejectRequest(requestId.toString(), telegramId, ctx);
    }
  } else if (data === 'start_work') {
    const assistant = await prisma.assistant.findUnique({ where: { telegramId: telegramId } });

    if (assistant?.isWorking) {
      await ctx.reply(getTranslation(lang, 'already_working'));
      return;
    }

    // –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞ –∫–∞–∫ —Ä–∞–±–æ—Ç–∞—é—â–µ–≥–æ
    await prisma.assistant.update({
      where: { telegramId: telegramId },
      data: { isWorking: true },
    });

    // –°–æ–∑–¥–∞—Ç—å —Å–µ—Å—Å–∏—é —Ä–∞–±–æ—Ç—ã –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
    await prisma.assistantSession.create({
      data: {
        assistantId: telegramId,
      },
    });

    const pendingRequest = await prisma.assistantRequest.findFirst({
      where: {
        status: 'PENDING',
      },
    });

    if (pendingRequest) {
      await prisma.assistantRequest.update({
        where: { id: pendingRequest.id },
        data: { assistantId: telegramId, status: 'IN_PROGRESS' },
      });

      await sendTelegramMessageWithButtons(
        telegramId.toString(),
        getTranslation(lang, 'assistantRequestMessage'),
        [
          { text: getTranslation(lang, 'accept'), callback_data: `accept_${pendingRequest.id}` },
          { text: getTranslation(lang, 'reject'), callback_data: `reject_${pendingRequest.id}` },
        ]
      );

      return;
    }

    await ctx.reply(getTranslation(lang, 'work_started'));
  } else if (data === 'my_coins') {
    // Handle displaying coins
    const assistant = await prisma.assistant.findUnique({
      where: { telegramId: telegramId },
    });

    if (assistant) {
      const coinsMessage = `${getTranslation(lang, 'my_coins')}: ${assistant.coins}`;

      await ctx.reply(coinsMessage, {
        reply_markup: {
          inline_keyboard: [
            [{ text: getTranslation(lang, 'request_withdrawal'), callback_data: 'request_withdrawal' }],
          ],
        },
      });
    } else {
      await ctx.reply(getTranslation(lang, 'end_dialog_error'));
    }
  } else if (data === 'my_activity') {
    // Handle displaying activity
    const stats = await getAssistantActivity(telegramId);

    const activityMessage = `
üìä ${getTranslation(lang, 'my_activity')}:
- ${getTranslation(lang, 'total_conversations')}: ${stats.totalConversations}
- ${getTranslation(lang, 'conversations_last_24_hours')}: ${stats.conversationsLast24Hours}
- ${getTranslation(lang, 'ignored_requests')}: ${stats.ignoredRequests}
- ${getTranslation(lang, 'rejected_requests')}: ${stats.rejectedRequests}
- ${getTranslation(lang, 'complaints_last_24_hours')}: ${stats.complaintsLast24Hours}
`;

    await ctx.reply(activityMessage, {
      reply_markup: {
        inline_keyboard: [
          [{ text: getTranslation(lang, 'view_limits'), callback_data: 'view_limits' }],
        ],
      },
    });
  } else if (data === 'request_withdrawal') {
    // Handle withdrawal request
    const assistant = await prisma.assistant.findUnique({
      where: { telegramId: telegramId },
    });

    if (assistant) {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);

      const pendingComplaints = await prisma.complaint.count({
        where: {
          assistantId: assistant.telegramId,
          status: 'PENDING',
        },
      });

      if (pendingComplaints > 0) {
        await ctx.reply(getTranslation(lang, 'complaint_pending'));
        return;
      }

      const rejectedActions = await prisma.requestAction.count({
        where: {
          assistantId: assistant.telegramId,
          action: 'REJECTED',
          createdAt: {
            gte: yesterday,
          },
        },
      });

      const ignoredActions = await prisma.requestAction.count({
        where: {
          assistantId: assistant.telegramId,
          action: 'IGNORED',
          createdAt: {
            gte: yesterday,
          },
        },
      });

      if (rejectedActions > 10 || ignoredActions > 3) {
        await ctx.reply(getTranslation(lang, 'balance_frozen'));
        return;
      }

      const withdrawalAmount = assistant.coins;

      await ctx.reply(getTranslation(lang, 'withdrawal_request_sent'));

      await prisma.withdrawalRequest.create({
        data: {
          userId: assistant.telegramId,
          userNickname: ctx.from?.username || null,
          userRole: 'assistant',
          amount: withdrawalAmount,
        },
      });

      await ctx.reply(getTranslation(lang, 'withdrawal_request_created'));
    } else {
      await ctx.reply(getTranslation(lang, 'end_dialog_error'));
    }
  } else if (data === 'view_limits') {
    // Handle viewing limits
    await ctx.reply(getTranslation(lang, 'limits_info'));
  } else {
    // Unknown callback data
    await ctx.answerCallbackQuery({ text: getTranslation(lang, 'unknown_action'), show_alert: true });
  }
});




async function getAssistantActivity(assistantId: bigint) {
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);


  const totalConversations = await prisma.conversation.count({
    where: { assistantId: assistantId },
  });


  const conversationsLast24Hours = await prisma.conversation.count({
    where: {
      assistantId: assistantId,
      createdAt: {
        gte: yesterday,
      },
    },
  });


  const ignoredRequests = await prisma.requestAction.count({
    where: {
      assistantId: assistantId,
      action: 'IGNORED',
      createdAt: {
        gte: yesterday,
      },
    },
  });


  const rejectedRequests = await prisma.requestAction.count({
    where: {
      assistantId: assistantId,
      action: 'REJECTED',
      createdAt: {
        gte: yesterday,
      },
    },
  });


  const complaintsLast24Hours = await prisma.complaint.count({
    where: {
      assistantId: assistantId,
      createdAt: {
        gte: yesterday,
      },
    },
  });

  return {
    totalConversations,
    conversationsLast24Hours,
    ignoredRequests,
    rejectedRequests,
    complaintsLast24Hours,
  };
}


async function handleAcceptRequest(requestId: string, assistantTelegramId: bigint, ctx: Context) {
  try {
    const assistantRequest = await prisma.assistantRequest.update({
      where: { id: BigInt(requestId) },
      data: { status: 'IN_PROGRESS', isActive: true },
      include: { user: true },
    });



    const existingConversation = await prisma.conversation.findFirst({
      where: { requestId: assistantRequest.id, status: 'ABORTED' },
    });

    if (existingConversation) {

      await prisma.conversation.update({
        where: { id: existingConversation.id },
        data: {
          assistantId: assistantTelegramId,
          messages: [],
          status: 'IN_PROGRESS',
          createdAt: new Date(),
          updatedAt: new Date(),
          lastMessageFrom: '',
          assistantResponseTimes: [],
          lastUserMessageAt: null,
        },
      });

      await ctx.reply('‚úÖ –í—ã –ø—Ä–∏–Ω—è–ª–∏ –∑–∞–ø—Ä–æ—Å.');

      await sendTelegramMessageToUser(
        assistantRequest.user.telegramId.toString(),
        '–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ —á–∞—Ç—É. –°—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π—Ç–µ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å.'
      );
    } else {

      await prisma.conversation.create({
        data: {
          userId: assistantRequest.userId,
          assistantId: assistantTelegramId,
          requestId: assistantRequest.id,
          messages: [],
          status: 'IN_PROGRESS',
          lastMessageFrom: 'USER',
        },
      });

      await ctx.reply('‚úÖ –í—ã –ø—Ä–∏–Ω—è–ª–∏ –∑–∞–ø—Ä–æ—Å. –û–∂–∏–¥–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.');

      await sendTelegramMessageToUser(
        assistantRequest.user.telegramId.toString(),
        '–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è –∫ —á–∞—Ç—É. –°—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π—Ç–µ —Å–≤–æ–π –≤–æ–ø—Ä–æ—Å.'
      );
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–Ω—è—Ç–∏–∏ –∑–∞–ø—Ä–æ—Å–∞:', error);
    await ctx.reply('‚ùå –î—Ä—É–≥–æ–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç —É–∂–µ –ø—Ä–∏–Ω—è–ª –∑–∞–ø—Ä–æ—Å.');
  }
}

async function handleRejectRequest(requestId: string, assistantTelegramId: bigint, ctx: Context) {
  try {
    const edges = await prisma.edges.findFirst();
    const maxRejects = edges ? edges.maxRejects : 7;

    const rejectCount = await prisma.requestAction.count({
      where: {
        assistantId: assistantTelegramId,
        action: 'REJECTED',
        createdAt: {
          gte: new Date(Date.now() - 24 * 60 * 60 * 1000),
        },
      },
    });

    if (rejectCount >= maxRejects) {
      await prisma.assistant.update({
        where: { telegramId: assistantTelegramId },
        data: {
          isBlocked: true,
          unblockDate: new Date(Date.now() + 24 * 60 * 60 * 1000),
        },
      });

      await ctx.reply('üö´ –í—ã –ø—Ä–µ–≤—ã—Å–∏–ª–∏ –ª–∏–º–∏—Ç –æ—Ç–∫–∞–∑–æ–≤ –∏ –±—ã–ª–∏ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –Ω–∞ 24 —á–∞—Å–∞.');
      return;
    }

    const assistantRequest = await prisma.assistantRequest.findUnique({
      where: { id: BigInt(requestId) },
      include: { conversation: true },
    });

    const ignoredAssistants = assistantRequest?.ignoredAssistants || [];
    ignoredAssistants.push(assistantTelegramId);

    if (assistantRequest?.conversation) {
      await prisma.conversation.update({
        where: { id: assistantRequest.conversation.id },
        data: { status: 'ABORTED' },
      });
    }

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è
    await prisma.requestAction.create({
      data: {
        requestId: BigInt(requestId),
        assistantId: assistantTelegramId,
        action: 'REJECTED',
      },
    });

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–ø—Ä–æ—Å–∞ –∏ –¥–æ–±–∞–≤–ª—è–µ–º –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º–æ–≥–æ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
    await prisma.assistantRequest.update({
      where: { id: BigInt(requestId) },
      data: {
        status: 'PENDING',
        isActive: true,
        assistantId: null,
        ignoredAssistants,
      },
    });

    // –ù–∞—Ö–æ–¥–∏–º –Ω–æ–≤–æ–≥–æ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
    const newAssistant = await findNewAssistant(BigInt(requestId), ignoredAssistants);

    if (newAssistant) {
      // –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å —Å –Ω–æ–≤—ã–º –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–º
      await prisma.assistantRequest.update({
        where: { id: BigInt(requestId) },
        data: {
          assistantId: newAssistant.telegramId,
        },
      });

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ–ª–µ subject –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
      if (assistantRequest?.subject) {
        const caption = '–¢–µ–º–∞ –∑–∞–ø—Ä–æ—Å–∞ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è';
        if (assistantRequest.subject.startsWith('http')) {
          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –º–µ–¥–∏–∞ (—Ñ–æ—Ç–æ, –≤–∏–¥–µ–æ, –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ)
          await sendTelegramMediaToAssistant(
            newAssistant.telegramId.toString(),
            assistantRequest.subject,
            caption
          );
        } else {
          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –±–µ–∑ –∫–Ω–æ–ø–æ–∫
          await sendTelegramMessageWithButtons(
            newAssistant.telegramId.toString(),
            `–¢–µ–º–∞ –∑–∞–ø—Ä–æ—Å–∞: ${assistantRequest.subject}`,
            []
          );
        }
      }

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–∞–º–∏
      await sendTelegramMessageWithButtons(
        newAssistant.telegramId.toString(),
        assistantRequest?.message || '–ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è',
        [
          { text: getTranslation('en', 'accept'), callback_data: `accept_${requestId}` },
          { text: getTranslation('en', 'reject'), callback_data: `reject_${requestId}` },
        ]
      );

      await ctx.reply('‚ùå –í—ã –æ—Ç–∫–ª–æ–Ω–∏–ª–∏ –∑–∞–ø—Ä–æ—Å. –ù–æ–≤—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω.');
    } else {
      await ctx.reply('‚ùå –í—ã –æ—Ç–∫–ª–æ–Ω–∏–ª–∏ –∑–∞–ø—Ä–æ—Å, –Ω–æ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–≤ –±–æ–ª—å—à–µ –Ω–µ—Ç.');
    }

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–∏ –∑–∞–ø—Ä–æ—Å–∞:', error);
    await ctx.reply('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–∏ –∑–∞–ø—Ä–æ—Å–∞.');
  }
}




// –û–±—â–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –º–µ–¥–∏–∞ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç—É
async function sendTelegramMediaToAssistant(userId: string, mediaUrl: string, caption: string): Promise<void> {
  try {
    if (mediaUrl.endsWith('.jpg') || mediaUrl.endsWith('.png')) {
      await sendPhoto(userId, mediaUrl, caption);
    } else if (mediaUrl.endsWith('.mp4')) {
      await sendVideo(userId, mediaUrl, caption);
    } else if (mediaUrl.endsWith('.ogg') || mediaUrl.endsWith('.mp3')) {
      await sendVoice(userId, mediaUrl);
    } else {
      console.error('Unsupported media type:', mediaUrl);
    }
  } catch (error) {
    console.error("Error sending media to assistant:", error);
    throw error;
  }
}


async function sendPhoto(userId: string, mediaUrl: string, caption: string): Promise<void> {
  try {
    // –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    const response = await axios.get(mediaUrl, { responseType: 'arraybuffer' });
    const buffer = Buffer.from(response.data, 'binary');

    // –û—Ç–ø—Ä–∞–≤–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    await assistantBot.api.sendPhoto(userId, new InputFile(buffer), { caption });
    console.log(`Photo sent to user ${userId}`);
  } catch (error) {
    console.error('Error sending photo:', error);
  }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤–∏–¥–µ–æ
async function sendVideo(userId: string, mediaUrl: string, caption: string) {
  try {
    await assistantBot.api.sendVideo(userId, mediaUrl, { caption });
    console.log(`Video sent to user ${userId}`);
  } catch (error) {
    console.error('Error sending video:', error);
  }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
async function sendVoice(userId: string, mediaUrl: string) {
  try {
    console.log(`sendVoice: Preparing to send voice message to assistant ${userId}`);
    console.log(`Media URL: ${mediaUrl}`);

    // –ó–∞–≥—Ä—É–∑–∫–∞ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
    const response = await axios.get(mediaUrl, { responseType: 'arraybuffer' });
    const voiceBuffer = Buffer.from(response.data, 'binary');
    const fileName = 'voice.ogg'; // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞ –¥–ª—è –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π

    console.log(`Sending voice message to assistant ${userId}`);
    await sendFileToAssistant(userId, voiceBuffer, fileName);

    console.log(`Voice message successfully sent to assistant ${userId}`);
  } catch (error) {
    console.error(`Error sending voice message to assistant ${userId}:`, error);
  }
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–∞–π–ª–∞ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç—É
async function sendFileToAssistant(assistantChatId: string, fileBuffer: Buffer, fileName: string) {
  const botToken = process.env.TELEGRAM_SUPPORT_BOT_TOKEN;
  if (!botToken) {
    console.error('–û—à–∏–±–∫–∞: TELEGRAM_SUPPORT_BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω');
    return;
  }

  const assistantBot = new Bot(botToken);

  try {
    await assistantBot.api.sendDocument(assistantChatId, new InputFile(fileBuffer, fileName));
    console.log(`File sent to assistant: ${assistantChatId}`);
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∞–π–ª–∞ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç—É:', error);
  }
}




const SESSION_DURATION = 60; // –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–µ—Å—Å–∏–∏ –≤ –º–∏–Ω—É—Ç–∞—Ö

bot.on('message', async (ctx) => {
  const lang = detectUserLanguage(ctx); // –ü–µ—Ä–µ–Ω–µ—Å–ª–∏ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ 'lang' –≤—ã—à–µ

  try {
    if (!ctx.from?.id) {
      await ctx.reply(getTranslation(lang, 'end_dialog_error'));
      return;
    }

    const assistantTelegramId = BigInt(ctx.from.id);

    // –ü–æ–ª—É—á–∞–µ–º –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞ –∏ –≤–∫–ª—é—á–∞–µ–º –∞–∫—Ç–∏–≤–Ω—É—é –±–µ—Å–µ–¥—É
    const assistant = await prisma.assistant.findUnique({
      where: { telegramId: assistantTelegramId },
      include: { activeConversation: true },
    });

    if (!assistant) {
      await ctx.reply(getTranslation(lang, 'no_assistant_found'));
      return;
    }

    if (!assistant.activeConversationId) {
      await ctx.reply(getTranslation(lang, 'no_active_requests'));
      return;
    }

    // –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç–∏–≤–Ω—É—é –±–µ—Å–µ–¥—É
    const activeConversation = await prisma.conversation.findUnique({
      where: { id: assistant.activeConversationId },
      include: { user: true },
    });

    if (!activeConversation) {
      await ctx.reply(getTranslation(lang, 'no_active_requests'));
      return;
    }

    const assistantMessage = ctx.message?.text;

    if (!assistantMessage) {
      await ctx.reply(getTranslation(lang, 'send_message_error'));
      return;
    }

    // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –æ—Å—Ç–∞–≤—à–µ–≥–æ—Å—è –≤—Ä–µ–º–µ–Ω–∏
    const conversationStartTime = new Date(activeConversation.createdAt);
    const currentTime = new Date();
    const elapsedMinutes = Math.floor((currentTime.getTime() - conversationStartTime.getTime()) / 60000);
    const remainingMinutes = Math.max(SESSION_DURATION - elapsedMinutes, 0);

    // –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –≤—Ä–µ–º–µ–Ω–∏
    const responseMessage = `
${assistantMessage}
--------------------------------
–î–æ –∫–æ–Ω—Ü–∞ —Å–µ–∞–Ω—Å–∞ –æ—Å—Ç–∞–ª–æ—Å—å ${remainingMinutes} –º–∏–Ω—É—Ç
    `;

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    await sendTelegramMessageToUser(
      activeConversation.userId.toString(),
      responseMessage
    );
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞:', error);
    await ctx.reply(getTranslation(lang, 'error_processing_message'));
  }
});



export const POST = webhookCallback(bot, 'std/http');
